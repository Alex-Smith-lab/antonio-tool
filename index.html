<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Antonio Advanced Annotation Tool</title>

<style>
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #111;
    color: white;
    display: flex;
    height: 100vh;
    overflow: hidden;
}

#main {
    flex: 4;
    display: flex;
    flex-direction: column;
    padding: 10px;
}

#toolbar {
    padding: 10px;
}

#workspace {
    flex: 1;
    overflow: auto;
    border: 2px solid #333;
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
}

canvas {
    cursor: crosshair;
    background: #000;
}

#sidebar {
    flex: 1;
    background: #1e1e1e;
    padding: 15px;
    overflow-y: auto;
    border-left: 2px solid #333;
}

button {
    margin: 5px;
    padding: 8px 12px;
    border: none;
    cursor: pointer;
    border-radius: 4px;
}

.green { background: #28a745; color: white; }
.red { background: #dc3545; color: white; }
.blue { background: #007bff; color: white; }
.gray { background: #6c757d; color: white; }

.annotation-item {
    background: #2c2c2c;
    padding: 8px;
    margin-bottom: 5px;
    border-radius: 4px;
    font-size: 12px;
}
</style>
</head>

<body>

<div id="main">

<div id="toolbar">
    <h2>Antonio Advanced Annotation Tool</h2>
    <input type="file" id="imageLoader" accept="image/*">
    <button class="green" onclick="enableDraw()">Add Box</button>
    <button class="red" onclick="deleteSelected()">Delete Selected</button>
    <button class="gray" onclick="clearAll()">Clear All</button>
    <button class="blue" onclick="downloadJSON()">Download JSON</button>
</div>

<div id="workspace">
    <canvas id="canvas"></canvas>
</div>

</div>

<div id="sidebar">
    <h3>Annotations</h3>
    <div id="annotationList"></div>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const imageLoader = document.getElementById("imageLoader");
const annotationList = document.getElementById("annotationList");

let img = new Image();
let annotations = [];
let selectedIndex = -1;

let drawing = false;
let resizing = false;
let dragging = false;
let resizeCorner = null;

let startX, startY;
let drawMode = false;

const handleSize = 6;

imageLoader.addEventListener("change", function(e) {
    const reader = new FileReader();
    reader.onload = function(event) {
        img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            redraw();
        }
        img.src = event.target.result;
    }
    reader.readAsDataURL(e.target.files[0]);
});

function enableDraw() {
    drawMode = true;
    selectedIndex = -1;
}

canvas.addEventListener("mousedown", function(e) {
    const {x, y} = getMousePos(e);

    if (drawMode) {
        drawing = true;
        startX = x;
        startY = y;
        return;
    }

    selectedIndex = getBoxAt(x, y);

    if (selectedIndex !== -1) {
        const corner = getCorner(x, y, annotations[selectedIndex]);
        if (corner) {
            resizing = true;
            resizeCorner = corner;
        } else {
            dragging = true;
            startX = x;
            startY = y;
        }
    }

    redraw();
});

canvas.addEventListener("mousemove", function(e) {
    const {x, y} = getMousePos(e);

    if (drawing) {
        redraw();
        ctx.strokeStyle = "red";
        ctx.strokeRect(startX, startY, x - startX, y - startY);
    }

    if (dragging && selectedIndex !== -1) {
        let box = annotations[selectedIndex];
        box.x += x - startX;
        box.y += y - startY;
        startX = x;
        startY = y;
        redraw();
    }

    if (resizing && selectedIndex !== -1) {
        let box = annotations[selectedIndex];

        if (resizeCorner === "tl") {
            box.width += box.x - x;
            box.height += box.y - y;
            box.x = x;
            box.y = y;
        }
        if (resizeCorner === "tr") {
            box.width = x - box.x;
            box.height += box.y - y;
            box.y = y;
        }
        if (resizeCorner === "bl") {
            box.width += box.x - x;
            box.x = x;
            box.height = y - box.y;
        }
        if (resizeCorner === "br") {
            box.width = x - box.x;
            box.height = y - box.y;
        }

        redraw();
    }
});

canvas.addEventListener("mouseup", function(e) {
    const {x, y} = getMousePos(e);

    if (drawing) {
        let newBox = {
            x: startX,
            y: startY,
            width: x - startX,
            height: y - startY,
            label: prompt("Enter label for this box:")
        };
        annotations.push(newBox);
        drawing = false;
        drawMode = false;
        redraw();
        updateSidebar();
    }

    resizing = false;
    dragging = false;
});

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
}

function redraw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0);

    annotations.forEach((box, index) => {
        ctx.strokeStyle = index === selectedIndex ? "yellow" : "red";
        ctx.lineWidth = 2;
        ctx.strokeRect(box.x, box.y, box.width, box.height);

        ctx.fillStyle = "red";
        ctx.fillText(box.label || "", box.x + 4, box.y - 4);

        drawHandles(box);
    });
}

function drawHandles(box) {
    ctx.fillStyle = "white";
    const corners = [
        [box.x, box.y],
        [box.x + box.width, box.y],
        [box.x, box.y + box.height],
        [box.x + box.width, box.y + box.height]
    ];
    corners.forEach(c => {
        ctx.fillRect(c[0] - handleSize/2, c[1] - handleSize/2, handleSize, handleSize);
    });
}

function getBoxAt(x, y) {
    for (let i = annotations.length - 1; i >= 0; i--) {
        let b = annotations[i];
        if (x >= b.x && x <= b.x + b.width &&
            y >= b.y && y <= b.y + b.height) {
            return i;
        }
    }
    return -1;
}

function getCorner(x, y, box) {
    const corners = {
        tl: [box.x, box.y],
        tr: [box.x + box.width, box.y],
        bl: [box.x, box.y + box.height],
        br: [box.x + box.width, box.y + box.height]
    };

    for (let key in corners) {
        let [cx, cy] = corners[key];
        if (Math.abs(x - cx) < handleSize &&
            Math.abs(y - cy) < handleSize) {
            return key;
        }
    }
    return null;
}

function deleteSelected() {
    if (selectedIndex !== -1) {
        annotations.splice(selectedIndex, 1);
        selectedIndex = -1;
        redraw();
        updateSidebar();
    }
}

function clearAll() {
    annotations = [];
    redraw();
    updateSidebar();
}

function updateSidebar() {
    annotationList.innerHTML = "";
    annotations.forEach((box, index) => {
        const div = document.createElement("div");
        div.className = "annotation-item";
        div.innerText = `${box.label} | x:${box.x.toFixed(0)}, y:${box.y.toFixed(0)}, w:${box.width.toFixed(0)}, h:${box.height.toFixed(0)}`;
        annotationList.appendChild(div);
    });
}

function downloadJSON() {
    const dataStr = "data:text/json;charset=utf-8," +
        encodeURIComponent(JSON.stringify(annotations, null, 2));
    const dl = document.createElement("a");
    dl.href = dataStr;
    dl.download = "annotations.json";
    dl.click();
}
</script>

</body>
</html>
