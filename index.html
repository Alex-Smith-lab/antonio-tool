<script>
const canvas=document.getElementById("canvas");
const ctx=canvas.getContext("2d");

const imageLoader=document.getElementById("imageLoader");
const imageList=document.getElementById("imageList");
const annotationList=document.getElementById("annotationList");
const popup=document.getElementById("labelPopup");
const labelSelect=document.getElementById("labelSelect");

let dataset=JSON.parse(localStorage.getItem("dataset"))||{};
let imagesMeta=JSON.parse(localStorage.getItem("imagesMeta"))||{};
let currentImage=null;
let img=new Image();

let scale=1, originX=0, originY=0;
let drawing=false, resizing=false, panning=false;
let startX,startY;
let selectedIndex=-1;
let resizeCorner=null;
let panStartX, panStartY;

const labelColors={
Car:"#ff3b3b",
Bus:"#00ff99",
Truck:"#3399ff",
Pedestrian:"#ffff00",
Train:"#ff00ff"
};

function saveData(){
localStorage.setItem("dataset",JSON.stringify(dataset));
localStorage.setItem("imagesMeta",JSON.stringify(imagesMeta));
}

/* IMAGE UPLOAD & PERSISTENCE */
imageLoader.addEventListener("change",e=>{
[...e.target.files].forEach(file=>{
const reader=new FileReader();
reader.onload=ev=>{
imagesMeta[file.name]={src:ev.target.result,complete:false};
dataset[file.name]=dataset[file.name]||[];
saveData();
renderImageList();
};
reader.readAsDataURL(file);
});
});

function renderImageList(){
imageList.innerHTML="";
for(let name in imagesMeta){
if(imagesMeta[name].complete) continue; // keep until complete
const div=document.createElement("div");
div.className="imageItem";
div.innerText=name;
div.onclick=()=>loadImage(name);
imageList.appendChild(div);
}
}

function loadImage(name){
currentImage=name;
img.src=imagesMeta[name].src;
img.onload=()=>{
canvas.width=img.width;
canvas.height=img.height;
scale=1; originX=0; originY=0;
redraw();
updateSidebar();
};
}

/* ZOOM */
canvas.addEventListener("wheel",e=>{
e.preventDefault();
const zoom=e.deltaY<0?1.1:0.9;
const mx=(e.offsetX-originX)/scale;
const my=(e.offsetY-originY)/scale;
scale*=zoom;
originX=e.offsetX-mx*scale;
originY=e.offsetY-my*scale;
redraw();
});

/* PAN */
document.addEventListener("keydown",e=>{
if(e.code==="Space") panning=true;
});
document.addEventListener("keyup",e=>{
if(e.code==="Space") panning=false;
});

canvas.addEventListener("mousedown",e=>{
const pos=getMouse(e);

if(panning){
panStartX=e.clientX;
panStartY=e.clientY;
return;
}

if(e.button===0){ // LEFT DRAW
selectedIndex=getBoxAt(pos.x,pos.y);
if(selectedIndex===-1){
drawing=true;
startX=pos.x;
startY=pos.y;
}
}

if(e.button===2){ // RIGHT RESIZE
e.preventDefault();
selectedIndex=getBoxAt(pos.x,pos.y);
if(selectedIndex!==-1){
resizeCorner=getCorner(dataset[currentImage][selectedIndex],pos.x,pos.y);
if(resizeCorner) resizing=true;
}
}
});

canvas.addEventListener("mousemove",e=>{
const pos=getMouse(e);

if(panning){
originX+=e.clientX-panStartX;
originY+=e.clientY-panStartY;
panStartX=e.clientX;
panStartY=e.clientY;
redraw();
return;
}

if(drawing){
redraw();
ctx.strokeStyle="white";
ctx.lineWidth=2/scale;
ctx.strokeRect(startX,startY,pos.x-startX,pos.y-startY);
}

if(resizing){
let box=dataset[currentImage][selectedIndex];
if(resizeCorner==="br"){ box.width=pos.x-box.x; box.height=pos.y-box.y; }
if(resizeCorner==="bl"){ box.width=(box.x+box.width)-pos.x; box.x=pos.x; box.height=pos.y-box.y; }
if(resizeCorner==="tr"){ box.width=pos.x-box.x; box.height=(box.y+box.height)-pos.y; box.y=pos.y; }
if(resizeCorner==="tl"){ box.width=(box.x+box.width)-pos.x; box.x=pos.x; box.height=(box.y+box.height)-pos.y; box.y=pos.y; }
redraw();
}
});

canvas.addEventListener("mouseup",e=>{
if(drawing){
const pos=getMouse(e);
let w = pos.x-startX;
let h = pos.y-startY;

// --- MODIFICATION HERE ---
// Only save if the box has a reasonable size (e.g., > 5 pixels)
if(Math.abs(w) > 5 && Math.abs(h) > 5){
    dataset[currentImage].push({
        x:startX,
        y:startY,
        width:w,
        height:h,
        label:"Car"
    });
    saveData();
    updateSidebar();
}
// -------------------------

drawing=false;
redraw();
}
if(resizing){
resizing=false;
saveData();
updateSidebar();
redraw();
}
});

/* POPUP ONLY IF DOUBLE CLICK ON BOX */
canvas.addEventListener("dblclick",e=>{
const pos=getMouse(e);
selectedIndex=getBoxAt(pos.x,pos.y);
if(selectedIndex!==-1){
popup.style.left=e.clientX+"px";
popup.style.top=e.clientY+"px";
popup.style.display="block";
}
});

canvas.addEventListener("contextmenu",e=>e.preventDefault());

function getMouse(e){
return{
x:(e.offsetX-originX)/scale,
y:(e.offsetY-originY)/scale
};
}

function getBoxAt(x,y){
if(!currentImage) return -1;
let arr=dataset[currentImage];
for(let i=arr.length-1;i>=0;i--){
let b=arr[i];
if(x>=b.x&&x<=b.x+b.width&&y>=b.y&&y<=b.y+b.height)
return i;
}
return -1;
}

function getCorner(box,x,y){
let size=10/scale; // Adjusted size for zoom level
if(Math.abs(x-(box.x+box.width))<size && Math.abs(y-(box.y+box.height))<size) return "br";
if(Math.abs(x-box.x)<size && Math.abs(y-(box.y+box.height))<size) return "bl";
if(Math.abs(x-(box.x+box.width))<size && Math.abs(y-box.y)<size) return "tr";
if(Math.abs(x-box.x)<size && Math.abs(y-box.y)<size) return "tl";
return null;
}

function redraw(){
if(!currentImage) return;
ctx.setTransform(scale,0,0,scale,originX,originY);
ctx.clearRect(-originX/scale,-originY/scale,canvas.width/scale,canvas.height/scale);
ctx.drawImage(img,0,0);

dataset[currentImage].forEach(box=>{
ctx.strokeStyle=labelColors[box.label];
ctx.lineWidth=2/scale;
ctx.strokeRect(box.x,box.y,box.width,box.height);
ctx.fillStyle=labelColors[box.label];
ctx.font = (16/scale) + "px Arial";
ctx.fillText(box.label,box.x+4,box.y-4);
});
}

function applyLabel(){
dataset[currentImage][selectedIndex].label=labelSelect.value;
popup.style.display="none";
saveData();
redraw();
updateSidebar();
}

function deleteSelected(){
if(selectedIndex!==-1){
dataset[currentImage].splice(selectedIndex,1);
selectedIndex=-1;
saveData();
redraw();
updateSidebar();
}
}

function clearCurrent(){
dataset[currentImage]=[];
saveData();
redraw();
updateSidebar();
}

function markComplete(){
if(currentImage){
imagesMeta[currentImage].complete=true;
saveData();
renderImageList();
}
}

function updateSidebar(){
annotationList.innerHTML="";
if(!currentImage) return;
dataset[currentImage].forEach(box=>{
const div=document.createElement("div");
div.className="annotation-item";
div.style.borderLeft="5px solid "+labelColors[box.label];
div.innerText=box.label;
annotationList.appendChild(div);
});
}

renderImageList();
</script>
